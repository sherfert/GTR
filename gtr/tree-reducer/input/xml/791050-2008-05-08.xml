<article xsi:noNamespaceSchemaLocation="http://jats.nlm.nih.gov/publishing/1.1/xsd/JATS-journalpublishing1-mathml3.xsd" dtd-version="1.1" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink"><front><journal-meta><journal-id journal-id-type="publisher-id">AAV</journal-id><journal-title-group><journal-title>Advances in Acoustics and Vibration</journal-title></journal-title-group><issn pub-type="epub">1687-627X</issn><issn pub-type="ppub">1687-6261</issn><publisher><publisher-name>Hindawi Publishing Corporation</publisher-name></publisher></journal-meta><article-meta><article-id pub-id-type="other">791050</article-id><article-id pub-id-type="doi">10.1155/2008/791050</article-id><article-id pub-id-type="publisher-id">791050</article-id><article-categories><subj-group subj-group-type="heading"><subject>Research Article</subject></subj-group></article-categories><title-group><article-title>Genetic Algorithm Applied to the Eigenvalue Equalization Filtered-x LMS Algorithm (EE-FXLMS)</article-title></title-group><contrib-group><contrib contrib-type="author" id="U64287913"><name><surname>Lovstedt</surname><given-names>Stephan P.</given-names></name><xref ref-type="aff" rid="I1"><sup>1</sup></xref></contrib><contrib contrib-type="author" id="U23219615"><name><surname>Thomas</surname><given-names>Jared K.</given-names></name><xref ref-type="aff" rid="I2"><sup>2</sup></xref></contrib><contrib contrib-type="author" id="U45291936" corresp="yes"><name><surname>Sommerfeldt</surname><given-names>Scott D.</given-names></name><xref ref-type="aff" rid="I1"><sup>1</sup></xref></contrib><contrib contrib-type="author" id="U67015929"><name><surname>Blotter</surname><given-names>Jonathan D.</given-names></name><xref ref-type="aff" rid="I2"><sup>2</sup></xref></contrib><contrib contrib-type="Academic Editor" id="U38196095"><name><surname>Pawelczyk</surname><given-names>Marek</given-names></name></contrib></contrib-group><aff id="I1"><sup>1</sup><addr-line>Department of Physics and Astronomy</addr-line><addr-line>College of Physical and Mathematical Sciences</addr-line><addr-line>N283 ESC</addr-line><addr-line>Brigham Young University</addr-line><addr-line> Provo, UT 84602</addr-line><country>USA</country><ext-link ext-link-type="domain-name">byu.edu</ext-link></aff><aff id="I2"><sup>2</sup><addr-line>Department of Mechanical Engineering</addr-line><addr-line>Ira A. Fulton College of Engineering and Technology</addr-line><addr-line>435 CTB</addr-line><addr-line>Brigham Young University</addr-line><addr-line>Provo, UT 84602</addr-line><country>USA</country><ext-link ext-link-type="domain-name">byu.edu</ext-link></aff><pub-date pub-type="publication-year"><year>2008</year></pub-date><pub-date pub-type="archival-date"><day>30</day><month>03</month><year>2008</year></pub-date><volume>2008</volume><history><date date-type="received"><day>12</day><month>12</month><year>2007</year></date><date date-type="accepted"><day>07</day><month>03</month><year>2008</year></date></history><permissions><copyright-year>2008</copyright-year><copyright-holder>Copyright &#xA9; 2008</copyright-holder><license xlink:href="http://creativecommons.org/licenses/by/4.0/"><license-p>This is an open access article distributed under the Creative Commons Attribution License, which permits unrestricted use, distribution, and reproduction in any medium, provided the original work is properly cited.</license-p></license></permissions><abstract><p>The FXLMS algorithm, used extensively in active noise control (ANC), exhibits frequency-dependent convergence behavior. This leads to degraded performance for time-varying tonal noise and noise with multiple stationary tones. Previous work by the authors proposed the eigenvalue equalization filtered-x least mean squares (EE-FXLMS) algorithm. For that algorithm, magnitude coefficients of the secondary path transfer function are modified to decrease variation in the eigenvalues of the filtered-x autocorrelation matrix, while preserving the phase, giving faster convergence and increasing overall attenuation. This paper revisits the EE-FXLMS algorithm, using a genetic algorithm to find magnitude coefficients that give the least variation in eigenvalues. This method overcomes some of the problems with implementing the EE-FXLMS algorithm arising from finite resolution of sampled systems. Experimental control results using the original secondary path model, and a modified secondary path model for both the previous implementation of EE-FXLMS and the genetic algorithm implementation are compared.</p></abstract><counts><ref-count count="14" /><page-count count="12" /></counts></article-meta></front><body><sec sec-type="section" id="sec1"><title>1. Introduction</title><p>The most common
control approach control (ANC) is the filtered-x least mean
squares (FXLMS) algorithm [<xref ref-type="bibr" rid="B1">1</xref>, <xref ref-type="bibr" rid="B2">2</xref>]. One of the limitations of the FXLMS
algorithm is that it exhibits frequency-dependent convergence
behavior that can lead to a significant degradation in the overall
performance of the control system. Two types of noise will be discussed as they
relate to this limitation.</p><p>(1) A single tone
with time-varying frequency, such as engine noise, where the engine firing frequency
changes along with the speed of the engine in revolutions per minute (rpm)
during operation. It is assumed that the signal power of the tone in the
reference remains the same, independent of frequency. This type of noise will
be referred to as &#x0201C;swept tone noise.&#x201d;</p><p>(2) Noise
containing multiple quasistationary tones, such as helicopter cabin noise,
where multiple rotating parts contribute strong tones that do not vary
significantly in frequency during normal operation. This type of noise will be
referred to as &#x201c;multiple tone noise.&#x201d;</p><p>Various
adaptations to the FXLMS algorithm have been developed in an effort to overcome
the performance loss due to its frequency-dependent convergence behavior. The
normalized FXLMS algorithm [<xref ref-type="bibr" rid="B3">3</xref>] has a variable convergence parameter that
changes with the power of the input for noise containing a single tone. Clark
and Gibbs and Lee et al. [<xref ref-type="bibr" rid="B4">4</xref>, <xref ref-type="bibr" rid="B5">5</xref>] developed a
method to process tonal components of a multiple tone noise problem separately
allowing for a different convergence parameter for each tone. More uniform
convergence and increased overall attenuation of all tones are achieved at the
expense of more computational complexity. Kuo et al. improved convergence for
multiple tone noise by optimizing the magnitude of internally generated
reference signals as the inverse of the secondary path magnitude [<xref ref-type="bibr" rid="B6">6</xref>].
This approach requires that the user have control over the reference tone
amplitudes. The drawback of most of these approaches is that they increase the
computational burden of the algorithm, increase the algorithm&#x2019;s complexity, or
are not applicable to one of the two types of noise considered here.</p><p>Elliot and Cook preconditioned the
input to the LMS update by using a second filter that was the inverse of the
minimum phase part of the secondary path estimate, thus &#x201c;whitening&#x201d; the input
and making convergence independent of resonances in the secondary path [<xref ref-type="bibr" rid="B7">7</xref>].</p><p>Prior research by the authors
proposed the eigenvalue equalization filtered-x least mean squares (EE-FXLMS)
algorithm [<xref ref-type="bibr" rid="B8">8</xref>]. This algorithm improves performance without increasing the
computational burden or complexity of the algorithm. The development of the
algorithm came from focusing on the eigenvalues of the autocorrelation matrix
of the filtered-x signal, which relate to the dynamics or time constants of the
modes of the system. Typically, there is a large spread in the eigenvalues of
this matrix, corresponding to fast and slow modes of convergence. If the
variance in the eigenvalues of the autocorrelation matrix is minimized,
convergence properties will be more uniform and controller parameters could be
optimized for all frequencies leading to increased performance (faster
convergence speed and additional noise attenuation) of the controller.</p><p>For
the EE-FXLMS algorithm, adjustments to the secondary path estimate are made in
the frequency domain. The phase of the original secondary path transfer
function estimate is preserved while the magnitude coefficients are adjusted to
have the inverse trend of tones in the reference signal. The new magnitude
coefficients are combined with the original phase response and transformed back
into the time domain, giving a new FIR estimate of the secondary path to filter
the reference signal. This is intended to equalize the power of tonal components
in the filtered-x signal, which in turn would equalize the eigenvalues of the
filtered-x autocorrelation matrix.</p><p>Previously,
the EE-FXLMS was implemented for swept tone noise by making each secondary path
transfer function coefficient flat (equal amplitude) over frequency because, as
noted, the power of the reference signal was independent of frequency.  For multiple tones, the trend of the
magnitude coefficients was made to be the inverse trend of the amplitudes of
the tones in the reference signal. For both cases, this led to more uniform
eigenvalues (of the filtered-x autocorrelation matrix), faster convergence
times, and additional attenuation at the error sensor [<xref ref-type="bibr" rid="B8">8</xref>].</p><p>This paper
revisits the EE-FXLMS implementation to modify the magnitude coefficients as
motivation for investigating improved methods of adjusting the magnitude
coefficients. In this work, a genetic algorithm is used to find the optimal
magnitude coefficients for a limited frequency range, swept tone noise, and for
a specific set of reference tones for multiple tone noise. Experimental results
for ANC in a mock cabin enclosure for these control implementations are
presented and compared.</p></sec><sec sec-type="section" id="sec2"><title>2. Background</title><p>The FXLMS
algorithm involves adaptively filtering a reference signal taken from the noise
source to create a control signal that attenuates the unwanted noise. The LMS
update is used to change the control filter coefficients such that the measured
residual noise is minimized. The measured residual is called the error signal
and for this research, it will be utilized to minimize a squared pressure (SP)
quantity. The mean squared error is a quadratic function of the filter
coefficients with a unique global optimum. The LMS update is a gradient descent
search method. It follows the path of steepest descent on the error surface
toward the optimum filter weights. A block diagram for a single-channel
implementation of the FXLMS algorithm is shown in Figure <xref ref-type="fig" rid="fig1">1</xref>. In Figure <xref ref-type="fig" rid="fig1">1</xref>, and in
all equations presented, the variable <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M1"><mml:mrow><mml:mi>t</mml:mi></mml:mrow></mml:math></inline-formula> is a discrete time index and the variable <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M2"><mml:mrow><mml:mi>z</mml:mi></mml:mrow></mml:math></inline-formula> a discrete frequency domain index.</p><fig id="fig1"><label>Figure 1</label><caption><p>Block diagram of the FXLMS algorithm.</p></caption><graphic xlink:href="791050.fig.001" /></fig><sec sec-type="subsection" id="subsec2.1"><title>2.1. Secondary Path Transfer Function</title><p>The FXLMS
algorithm derives its name from the filtered-x signal, <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M3"><mml:mrow><mml:mi>r</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>, which is the
convolution of the reference signal <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M4"><mml:mrow><mml:mi>x</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>, with <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M5"><mml:mrow><mml:mover><mml:mrow><mml:mi mathvariant="bold">h</mml:mi></mml:mrow><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>, a finite
impulse response (FIR) estimate of the secondary path transfer function. The
secondary path transfer function (shown in Figure <xref ref-type="fig" rid="fig1">1</xref> as <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M6"><mml:mrow><mml:mi mathvariant="bold">H</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>z</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>) includes the effects
of digital-to-analog and analog-to-digital converters, filters, audiopower
amplifiers, loudspeakers, the acoustical transmission path, error sensors, and
other signal conditioning.</p><p>The
secondary path model, <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M7"><mml:mrow><mml:mover><mml:mrow><mml:mi mathvariant="bold">H</mml:mi></mml:mrow><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>z</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>, is
estimated through a process called system identification (SysID). The SysID
process is performed offline (before ANC is started) for the fastest
convergence of the algorithm where the secondary path does not change
significantly during operation of the system. Band-limited white noise is
played through the control speaker(s) and the output is measured at the error
sensor(s). The measured impulse response is obtained as an FIR filter, <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M8"><mml:mrow><mml:mover><mml:mrow><mml:mi mathvariant="bold">h</mml:mi></mml:mrow><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>, that
represents <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M9"><mml:mrow><mml:mover><mml:mrow><mml:mi mathvariant="bold">H</mml:mi></mml:mrow><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>z</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>. The
coefficients of <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M10"><mml:mrow><mml:mover><mml:mrow><mml:mi mathvariant="bold">h</mml:mi></mml:mrow><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> are
stored and used to prefilter the input signal to the LMS update to run control.
While inclusion of <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M11"><mml:mrow><mml:mover><mml:mrow><mml:mi mathvariant="bold">H</mml:mi></mml:mrow><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>z</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> is
necessary for stability, the FXLMS algorithm is robust to errors in its
estimation. The algorithm will converge (slowly) as long as phase errors are
less than 90<sup><italic>&#x2da;</italic></sup> [<xref ref-type="bibr" rid="B1">1</xref>] and phase errors less than 40<sup><italic>&#x2da;</italic></sup> do not significantly affect
convergence [<xref ref-type="bibr" rid="B9">9</xref>]. The gain applied to the reference signal by filtering it with <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M12"><mml:mrow><mml:mover><mml:mrow><mml:mi mathvariant="bold">h</mml:mi></mml:mrow><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> does not
affect the stability of the algorithm and is usually compensated for by
modifying the convergence parameter <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M13"><mml:mrow><mml:mi>&#x3bc;</mml:mi></mml:mrow></mml:math></inline-formula>.</p></sec><sec sec-type="subsection" id="subsec2.2"><title>2.2. FXLMS Convergence and Eigenvalues of Filtered-X
Autocorrelation Matrix</title><p>The time constants
for the modes of convergence of the ANC system are determined by the eigenvalues
of the autocorrelation matrix of the filtered-x signal [<xref ref-type="bibr" rid="B10">10</xref>]. While the
convergence parameter, <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M14"><mml:mrow><mml:mi>&#x3bc;</mml:mi></mml:mrow></mml:math></inline-formula>, can be optimized to give fast convergence for one
mode, others will converge more slowly. For swept tone noise, <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M15"><mml:mrow><mml:mi>&#x3bc;</mml:mi></mml:mrow></mml:math></inline-formula> can be
optimized for a given frequency in the range of the sweep, but not for all
frequencies in the range. When the algorithm is controlling a tone at a
frequency other than that for which it was optimized, convergence will be
slower and attenuation less. For multiple tone noise, the algorithm will be
able to attenuate portions of the total noise quickly while other tones in the
noise will linger and take longer to converge.</p><p>The
properties of the filtered-x signal, and hence the autocorrelation matrix, are
a function of the magnitude response of <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M16"><mml:mrow><mml:mover><mml:mrow><mml:mi mathvariant="bold">H</mml:mi></mml:mrow><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>z</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> and the
spectrum of the reference signal. The autocorrelation matrix of the filtered-x
signal is defined as <disp-formula id="eq1"><label>(1)</label><mml:math altimg="C:\WINDOWS\Temp\MMLIMG8580.png" width="150" height="39" xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M17"><mml:mrow><mml:mi mathvariant="bold">R</mml:mi><mml:mo>=</mml:mo><mml:mi>E</mml:mi><mml:mrow><mml:mo minsize="1em" maxsize="1em">[</mml:mo><mml:mi mathvariant="bold">r</mml:mi><mml:mrow><mml:mo minsize="0.75em" maxsize="0.75em">(</mml:mo><mml:mi>t</mml:mi><mml:mo minsize="0.75em" maxsize="0.75em">)</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="bold">r</mml:mi></mml:mrow><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msup><mml:mrow><mml:mo minsize="0.75em" maxsize="0.75em">(</mml:mo><mml:mi>t</mml:mi><mml:mo minsize="0.75em" maxsize="0.75em">)</mml:mo></mml:mrow></mml:mrow><mml:mo minsize="1em" maxsize="1em">]</mml:mo><mml:mo>,</mml:mo></mml:mrow></mml:mrow></mml:math></disp-formula> where <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M18"><mml:mrow><mml:mi>E</mml:mi><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mo>&#x22c5;</mml:mo><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> denotes the expected value of the operand which is the
filtered-x signal vector, <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M19"><mml:mrow><mml:mi mathvariant="bold">r</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>,
multiplied by the filtered-x signal vector transposed <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M20"><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="bold">r</mml:mi></mml:mrow><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>.  In
general, it has been shown that the FXLMS algorithm (or any of its variations)
will converge (in the mean) and remain stable as long as the chosen <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M21"><mml:mrow><mml:mi>&#x3bc;</mml:mi></mml:mrow></mml:math></inline-formula> satisfies
the following equation [<xref ref-type="bibr" rid="B9">9</xref>]: <disp-formula id="eq2"><label>(2)</label><mml:math altimg="C:\WINDOWS\Temp\MMLIMG8585.png" width="111" height="48" xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M22"><mml:mrow><mml:mn>0</mml:mn><mml:mo>&#x3c;</mml:mo><mml:mi>&#x3bc;</mml:mi><mml:mo>&#x3c;</mml:mo><mml:mfrac><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>&#x3bb;</mml:mi></mml:mrow><mml:mrow><mml:mi>max</mml:mi><mml:mo>&#x2009;</mml:mo></mml:mrow></mml:msub></mml:mrow></mml:mfrac><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula> where <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M23"><mml:mrow><mml:msub><mml:mrow><mml:mi>&#x3bb;</mml:mi></mml:mrow><mml:mrow><mml:mi>max</mml:mi><mml:mo>&#x2009;</mml:mo></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> is the
maximum eigenvalue of the autocorrelation matrix.</p><p>In
practice, it is computationally demanding to obtain a real-time estimate of the
autocorrelation matrix, so the optimal <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M24"><mml:mrow><mml:mi>&#x3bc;</mml:mi></mml:mrow></mml:math></inline-formula> is often selected through
experimentation. In this work, the structure of the eigenvalues of a given ANC
problem is explored using an offline estimate of the autocorrelation matrix.
This is done in a numerical analysis program by taking an actual <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M25"><mml:mrow><mml:mover><mml:mrow><mml:mi mathvariant="bold">h</mml:mi></mml:mrow><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> model
from a mock cabin enclosure, convolving this with a reference signal for the
given noise application, computing the autocorrelation matrix, and getting the
eigenvalues. If a single frequency reference signal is used, <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M26"><mml:mrow><mml:msub><mml:mrow><mml:mi>&#x3bb;</mml:mi></mml:mrow><mml:mrow><mml:mi>max</mml:mi><mml:mo>&#x2009;</mml:mo></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> can be computed for that frequency.  If
the simulation is repeated over a range of frequencies, <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M27"><mml:mrow><mml:msub><mml:mrow><mml:mi>&#x3bb;</mml:mi></mml:mrow><mml:mrow><mml:mi>max</mml:mi><mml:mo>&#x2009;</mml:mo></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> for a
single tone at each frequency in that range can be found.  For control of a single tone, <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M28"><mml:mrow><mml:msub><mml:mrow><mml:mi>&#x3bb;</mml:mi></mml:mrow><mml:mrow><mml:mi>max</mml:mi><mml:mo>&#x2009;</mml:mo></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> is the only eigenvalue of interest since it will determine the convergence of
the algorithm for that frequency. Figure <xref ref-type="fig" rid="fig2">2</xref> (solid line) shows an offline
simulation using an actual <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M29"><mml:mrow><mml:mover><mml:mrow><mml:mi mathvariant="bold">h</mml:mi></mml:mrow><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> from the
mock cabin enclosure, and equal amplitude tonal inputs from 0&#x2013;300&#x2009;Hz. The
disparity in <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M30"><mml:mrow><mml:msub><mml:mrow><mml:mi>&#x3bb;</mml:mi></mml:mrow><mml:mrow><mml:mi>max</mml:mi><mml:mo>&#x2009;</mml:mo></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> over frequency shows how the convergence of the
algorithm will change as it controls a single tone swept through this range.
The range of interest from 0&#x2013;300&#x2009;Hz was
selected because the experimental hardware was set with a cutoff frequency at
400&#x2009;Hz. The eigenvalues in the figure have been normalized to the largest
eigenvalue in the range.</p><fig id="fig2"><label>Figure 2</label><caption><p>Plot of normalized maximum eigenvalues over frequency for original and
modified (flat magnitude) eigenvalues.</p></caption><graphic xlink:href="791050.fig.002" /></fig><p>The
largest eigenvalue for a single tone occurs at about 125&#x2009;Hz. This location
corresponds to the largest <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M31"><mml:mrow><mml:mi>&#x3bc;</mml:mi></mml:mrow></mml:math></inline-formula> that is stable for the entire frequency range from
0&#x2013;400&#x2009;Hz as given
by (<xref ref-type="disp-formula" rid="eq2">2</xref>). All other frequencies have a
smaller eigenvalue and could use a larger <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M32"><mml:mrow><mml:mi>&#x3bc;</mml:mi></mml:mrow></mml:math></inline-formula>, and still be stable, if just that
particular frequency was targeted for control. Frequencies at the valleys of
the solid line in Figure <xref ref-type="fig" rid="fig2">2</xref> have the smallest eigenvalues and could use the
largest <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M33"><mml:mrow><mml:mi>&#x3bc;</mml:mi></mml:mrow></mml:math></inline-formula>&#x2019;s and still be stable, again if they were the only frequencies
targeted for control. The larger <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M34"><mml:mrow><mml:mi>&#x3bc;</mml:mi></mml:mrow></mml:math></inline-formula>&#x2019;s are especially desirable for nonstationary
noise as they lead to faster convergence and increased attenuation.</p><p>For
multiple tone noise that is stationary, the eigenvalues are not computed for
individual tones as before, but for the composite reference signal containing
all tones to be controlled. In this case, the disparity among all of the
nonzero eigenvalues, not just <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M35"><mml:mrow><mml:msub><mml:mrow><mml:mi>&#x3bb;</mml:mi></mml:mrow><mml:mrow><mml:mi>max</mml:mi><mml:mo>&#x2009;</mml:mo></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, gives information about how
different spectral components of multiple tone noise will converge.</p></sec></sec><sec sec-type="section" id="sec3"><title>3. Eigenvalue Equalization&#x2014;Prior Methods</title><p>If the variance in
the eigenvalues of the autocorrelation matrix was minimized, a single-convergence
parameter could then be chosen that would be nearly optimal for all frequencies
targeted for control and the algorithm would converge at nearly the same rate
at all frequencies or for all modes of convergence. Additionally,
&#x201c;misadjustment&#x201d; errors that prevent the algorithm from converging to the true
optimal solution depend on the eigenvalues of the autocorrelation matrix.
Misadjustment error is larger when there is large disparity in the eigenvalues
[<xref ref-type="bibr" rid="B11">11</xref>]. Misadjustment (and hence attenuation) can be improved by making these
eigenvalues equal.</p><p>As
previously stated, the autocorrelation matrix is directly dependent on the
filtered-x signal, which is computed by filtering the input reference signal,
<inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M36"><mml:mrow><mml:mi>x</mml:mi><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>, with <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M37"><mml:mrow><mml:mover><mml:mrow><mml:mi mathvariant="bold">H</mml:mi></mml:mrow><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>z</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>. Any
attempt at equalizing the eigenvalues must be done by altering either the
reference signal or the secondary path model. Adjusting the power of the
reference signal has been shown to be an effective way of doing this [<xref ref-type="bibr" rid="B6">6</xref>];
however, in many applications this amount of control over the reference signal
is not feasible. We focus on making changes to <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M38"><mml:mrow><mml:mover><mml:mrow><mml:mi mathvariant="bold">H</mml:mi></mml:mrow><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>z</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> only. The
span, defined as <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M39"><mml:mrow><mml:msub><mml:mrow><mml:mi>&#x3bb;</mml:mi></mml:mrow><mml:mrow><mml:mi>max</mml:mi><mml:mo>&#x2009;</mml:mo></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> divided by <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M40"><mml:mrow><mml:msub><mml:mrow><mml:mi>&#x3bb;</mml:mi></mml:mrow><mml:mrow><mml:mi>min</mml:mi><mml:mo>&#x2009;</mml:mo></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>,  is used as a metric to quantify any
improvement in the eigenvalue disparity. This ratio is the most important
property, as any change in the actual magnitude of the eigenvalues is
compensated for by making a complementary adjustment to the magnitude of the
convergence parameter <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M41"><mml:mrow><mml:mi>&#x3bc;</mml:mi></mml:mrow></mml:math></inline-formula>.</p><sec sec-type="subsection" id="subsec3.1"><title>3.1. Eigenvalue Equalization Applied to Swept Tone Noise</title><p>For swept tone noise,
it has been shown that flattening the magnitude coefficients of <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M42"><mml:mrow><mml:mover><mml:mrow><mml:mi mathvariant="bold">H</mml:mi></mml:mrow><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>z</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>, while
preserving the phase reduces the variance in the eigenvalues [<xref ref-type="bibr" rid="B8">8</xref>]. Figure <xref ref-type="fig" rid="fig2">2</xref>
shows both the original eigenvalues (solid line) and the modified eigenvalues
(dotted line) when the magnitude coefficients of <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M43"><mml:mrow><mml:mover><mml:mrow><mml:mi mathvariant="bold">H</mml:mi></mml:mrow><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>z</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> are
flattened. In the figure, the eigenvalues for both the original and modified
cases have been normalized by the largest of the original eigenvalues. The span
for the original eigenvalues in this range (0&#x2013;400&#x2009;Hz on the plot)
is 1.385 &#xd7; 10<sup>5</sup> and the span for the flattened magnitude <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M44"><mml:mrow><mml:mover><mml:mrow><mml:mi mathvariant="bold">H</mml:mi></mml:mrow><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>z</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> is 162.3.
These modifications to <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M45"><mml:mrow><mml:mover><mml:mrow><mml:mi mathvariant="bold">H</mml:mi></mml:mrow><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>z</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> make a
noticeable improvement in the performance of the algorithm [<xref ref-type="bibr" rid="B8">8</xref>]. The more
uniform rate of convergence of all modes of the system is beneficial as it
speeds up the overall convergence of the error signal. For dynamic signals,
this increased rate of convergence equates to greater attenuation, as it also
results in more rapid tracking.</p><p>The
eigenvalues are much more uniform, but still not perfectly uniform. This is due
to the finite resolution of the digital system and of the sampled secondary
path estimate. The shape of the magnitude response, <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M46"><mml:mrow><mml:mover><mml:mrow><mml:mi mathvariant="bold">H</mml:mi></mml:mrow><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>z</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>, can only
be constrained to some value at its respective frequency bins; there is no
guarantee that the response of <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M47"><mml:mrow><mml:mover><mml:mrow><mml:mi mathvariant="bold">H</mml:mi></mml:mrow><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>z</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> is also
flat between frequency bins. As an example, a 128 coefficient <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M48"><mml:mrow><mml:mover><mml:mrow><mml:mi mathvariant="bold">H</mml:mi></mml:mrow><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>z</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> model
sampled at 2000&#x2009;Hz will have a frequency resolution of 15.625&#x2009;Hz. For swept
tone noise, the system may be excited at any frequency in the range of the
application. An estimate of the &#x201c;analog&#x201d; or continuous response of <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M49"><mml:mrow><mml:mover><mml:mrow><mml:mi mathvariant="bold">H</mml:mi></mml:mrow><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>z</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> between
frequency bins can be made by zero padding the 128-coefficient model before
computing the fast Fourier transform (FFT). The original, flattened, and zero-padded
flattened magnitude coefficients of  <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M50"><mml:mrow><mml:mover><mml:mrow><mml:mi mathvariant="bold">H</mml:mi></mml:mrow><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>z</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> from a
mock cabin are shown in Figure <xref ref-type="fig" rid="fig3">3</xref>. The discrete magnitude response is indeed
flat at the frequency bin values, but the zero-padded model shows that the true
response deviates from flat in between bins. This magnitude variation between
frequency bins in <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M51"><mml:mrow><mml:mover><mml:mrow><mml:mi mathvariant="bold">H</mml:mi></mml:mrow><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>z</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>
contributes to the residual variation seen in the modified eigenvalues for the
range.</p><fig id="fig3"><label>Figure 3</label><caption><p>Plot of original-, flattened-, and zero-padded flattened magnitude
coefficients of  <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M52"><mml:mrow><mml:mover><mml:mrow><mml:mi mathvariant="bold">H</mml:mi></mml:mrow><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>z</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>.</p></caption><graphic xlink:href="791050.fig.003" /></fig><p>Another
source of variation may come from frequency leakage when the reference signal
gets downsampled before being convolved with <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M53"><mml:mrow><mml:mover><mml:mrow><mml:mi mathvariant="bold">h</mml:mi></mml:mrow><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>. Before
being convolved with <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M54"><mml:mrow><mml:mover><mml:mrow><mml:mi mathvariant="bold">h</mml:mi></mml:mrow><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>, the
reference signal is downsampled with the same sampling frequency as was used to
find <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M55"><mml:mrow><mml:mover><mml:mrow><mml:mi mathvariant="bold">h</mml:mi></mml:mrow><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>; for this
example, 2000&#x2009;Hz was used. In addition, only <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M56"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:math></inline-formula> number of samples are kept of the reference signal at a given
time, where <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M57"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:math></inline-formula> is the number of
coefficients in <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M58"><mml:mrow><mml:mover><mml:mrow><mml:mi mathvariant="bold">h</mml:mi></mml:mrow><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>; for this
example, 128 was used. This downsampling process causes amplitude estimation
error in the frequency domain due to leakage. Thus if the original reference
signal is assumed to be equally weighted at each frequency, as was done to
create the eigenvalue simulations shown in Figure <xref ref-type="fig" rid="fig2">2</xref>, the actual reference
signal used in those simulations is no longer equally weighted over frequency.
This also contributes to residual variation in the eigenvalues.</p></sec><sec sec-type="subsection" id="subsec3.2"><title>3.2. Eigenvalue Equalization Applied to Multiple Tone Noise</title><p>When multiple
noise sources are present, a reference signal may be obtained from each and
combined into a single-reference signal. In some cases, the reference signal
will contain a fundamental frequency and harmonics from a single-noise source.
In either case, the combined tones in the reference signal will in general have
different amplitudes. This weighting of the reference tones will be specific to
each application and depends on how the reference signals are conditioned and
combined. This frequency-dependent weighting of the reference tones as well as
the gain applied by the secondary path estimate contributes to the eigenvalue
disparity for multiple tone noise. For multiple tone noise in this research, an
arbitrary (but specific, for consistency) weighting was applied to the
reference tones. The amplitude of the reference signal tones was defined by <disp-formula id="eq3"><label>(3)</label><mml:math altimg="C:\WINDOWS\Temp\MMLIMG8622.png" width="405" height="25" xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M59"><mml:mrow><mml:mtext>Tonal</mml:mtext><mml:mo>&#x2009;</mml:mo><mml:mtext>&#x2009;</mml:mtext><mml:mtext>&#x2009;</mml:mtext><mml:mtext>Amplitude</mml:mtext><mml:mo>=</mml:mo><mml:mo>&#x2212;</mml:mo><mml:msup><mml:mrow><mml:mn>0.0036</mml:mn></mml:mrow><mml:mrow><mml:mo>&#x2a;</mml:mo></mml:mrow></mml:msup><mml:mrow><mml:mo minsize="0.75em" maxsize="0.75em">(</mml:mo><mml:mtext>Tonal</mml:mtext><mml:mo>&#x2009;</mml:mo><mml:mtext>&#x2009;</mml:mtext><mml:mtext>&#x2009;</mml:mtext><mml:mtext>Frequency</mml:mtext><mml:mo minsize="0.75em" maxsize="0.75em">)</mml:mo><mml:mo>+</mml:mo><mml:mn>1.18.</mml:mn></mml:mrow></mml:mrow></mml:math></disp-formula> This gave a decreasing trend in
amplitude for increasing frequency that ranged from 1.0 at 50&#x2009;Hz to 0.1 at 300&#x2009;Hz. All tones used for the multiple tone noise were in this range.</p><p>To equalize the
eigenvalues for this case, a trend line connecting the peaks of the tones (on a
power spectrum plot) in the reference is drawn. The inverse of this line gives
the desired trend for the magnitude coefficients in <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M60"><mml:mrow><mml:mover><mml:mrow><mml:mi mathvariant="bold">H</mml:mi></mml:mrow><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>z</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>, which
here corresponds to the inverse of (<xref ref-type="disp-formula" rid="eq3">3</xref>). Since the tonal amplitudes for the test
case were specified, obtaining the inverse trend line was straightforward. In
actual implementation, an offline &#x201c;Ref ID&#x201d; process would also be required. This
would entail recording the reference signal under normal operating conditions
for the system at the sampling frequency used by the controller. The desired
magnitude trend for the modified Sys ID filter could be obtained from the fast
Fourier transform (FFT) or power spectrum plot of the reference.</p><p>This
type of modified <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M61"><mml:mrow><mml:mover><mml:mrow><mml:mi mathvariant="bold">H</mml:mi></mml:mrow><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>z</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> is
designated as an &#x201c;X-inverse&#x201d; model. Figure <xref ref-type="fig" rid="fig4">4</xref> shows the trend line for the
amplitude of tones in the reference as given by (<xref ref-type="disp-formula" rid="eq3">3</xref>), the desired magnitude
response for <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M62"><mml:mrow><mml:mover><mml:mrow><mml:mi mathvariant="bold">H</mml:mi></mml:mrow><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>z</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>,  and the zero-padded response of the 256
coefficients X-inverse model. All curves have been normalized in the figure. As
before, the response of the filter between bins deviates from the trend
assigned the coefficients. Increasing the coefficients from 128 to 256 makes
the magnitude response match the desired curve at more points, but does not
improve the variation between bins. The same is true for the phase response.</p><fig id="fig4"><label>Figure 4</label><caption><p>Reference tone amplitude trend line for multiple tone noise signals with
desired trend and zero-padded X-inverse model magnitude responses.</p></caption><graphic xlink:href="791050.fig.004" /></fig><p>This
method will reduce the eigenvalue variation only for some cases. If the tones
in the reference are chosen to correspond exactly to frequency bin values, the
eigenvalues are much more uniform using the X-inverse model than using the
original model. However, if the tones lie off these frequency bin values, the
eigenvalue span can be worse than for the unmodified <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M63"><mml:mrow><mml:mover><mml:mrow><mml:mi mathvariant="bold">H</mml:mi></mml:mrow><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>z</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>.</p><p>Two reference
signals containing six tones were made for comparison; one with all six tones
on frequency bins (62.5, 93.75, 125, 171.875, 203.125, and 296.875&#x2009;Hz) and the
other with these tones shifted slightly to lie between bin values (50, 100,
130, 180, 200, and 280&#x2009;Hz). The length of the FIR filter model of <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M64"><mml:mrow><mml:mover><mml:mrow><mml:mi mathvariant="bold">H</mml:mi></mml:mrow><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>z</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> was
increased from 128 to 256 to double the resolution in an attempt to constrain
the magnitude response between bins to follow more closely the desired trend.
The eigenvalue span for these reference signals with the original and X-inverse <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M65"><mml:mrow><mml:mover><mml:mrow><mml:mi mathvariant="bold">H</mml:mi></mml:mrow><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>z</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> models of
different lengths were calculated. The results of these comparisons are shown
in Table <xref ref-type="table" rid="tab1">1</xref>. When the tones lie on the frequency bins, the X-inverse model gives
a significant improvement in the eigenvalue span. For offbin frequencies the X-inverse
model is better than the original for the 128-coefficient filter, but not as
good as when the tones are on bins. When the filter length is increased to 256,
the span for the X-inverse model was worse than the original model for offbin
tones. The span for the X-inverse model with 256 coefficients went from 239 to
991 likely because the magnitude response of the X-inverse model goes almost to
zero at 200&#x2009;Hz (see Figure <xref ref-type="fig" rid="fig4">4</xref>). Increasing the resolution by using a longer
filter does not (at least in some cases) improve the eigenvalue span. This
gives the desired magnitude response at a larger number of points, but the
deviation from the desired trend in between these points is not necessarily
improved.</p><table-wrap id="tab1"><label>Table 1</label><caption><p>Comparison of eigenvalue span for original and X-inverse models for multiple tones with frequencies on and off frequency bin values.</p></caption><table><thead><tr><th align="left" /><th align="center">Sys ID length</th><th align="center">Original</th><th align="center">X-inverse</th></tr></thead><tbody><tr><td align="left" rowspan="2"> Tones on bin values</td><td align="center">128</td><td align="center">4350</td><td align="center">2.0</td></tr><tr><td align="center">256</td><td align="center">2162</td><td align="center">2.0</td></tr><tr><td align="left" rowspan="2">Tones off bin values</td><td align="center">128</td><td align="center">217</td><td align="center">16</td></tr><tr><td align="center">256</td><td align="center">239</td><td align="center">991</td></tr></tbody></table></table-wrap><p>The eigenvalue
span for the 128-coeffficient X-inverse model and tones at offbin frequency
values was reduced significantly over the original model from 217 to 16.
However, Figure <xref ref-type="fig" rid="fig5">5</xref> shows that the phase errors introduced exceed stability
limits near several tones in the reference. Horizontal lines mark 40<sup><italic>&#x2da;</italic></sup> and 90<sup><italic>&#x2da;</italic></sup>
of phase error between the original and modified phase response and vertical
dashed lines show the positions of offbin reference tones. Phase errors introduced into
regions where no tonal components of the noise are being controlled will not
affect the stability or performance of the system. For helicopters, the tones
in the noise are very stable and do not shift in frequency significantly,
however, phase errors very near those tonal frequencies are potentially
problematic for both stability and overall performance of the ANC system.</p><fig id="fig5"><label>Figure 5</label><caption><p>Phase difference between 128-coefficient original and X-inverse models with
reference tones off frequency bin values. Dashed lines indicate tonal frequencies.</p></caption><graphic xlink:href="791050.fig.005" /></fig><p>In this case, even
though the eigenvalue span was improved, the X-inverse model would not work
well if used in ANC since instability and poor performance would result from
the phase issues. This is another reason the X-inverse method is inadequate.</p><p>The inability to
control the magnitude and phase response of the secondary path estimate in
between frequency bin values and the unpredictable changes that occur in each
when the magnitude coefficients of the original model are modified make the X-inverse
method of eigenvalue equalization inadequate. A genetic algorithm approach was
developed to optimize the magnitude coefficients, and which can overcome these
difficulties for multiple tone noise.</p></sec></sec><sec sec-type="section" id="sec4"><title>4. Eigenvalue Equalization&#x2014;Genetic Algorithm</title><p>A genetic algorithm was used to investigate
the possibility of getting more uniform eigenvalues over narrow bands of
frequencies for swept tone noise and for specific multiple tone noise cases.
Optimizing the magnitude coefficients of <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M66"><mml:mrow><mml:mover><mml:mrow><mml:mi mathvariant="bold">H</mml:mi></mml:mrow><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>z</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> in ways
other than those described previously may lead to improved eigenvalue span, but
are not intuitive. Genetic algorithms (GAs) [<xref ref-type="bibr" rid="B12">12</xref>, <xref ref-type="bibr" rid="B13">13</xref>] have gained considerable
popularity in recent years for their ability to solve problems with a large
number of design variables, multiple local minima and maxima, nondifferentiable
functions, or some combinations of these. They can work well for both discrete-
and real-valued problems. GA&#x2019;s mimic the natural selection process found in
nature that allows individuals with the best &#x201c;fitness&#x201d; to survive. Parents are
chosen from the most fit individuals of a population of randomly generated
designs. These parents are then sent through a reproduction process to exchange
and pass on genetic information to new designs (children). As in nature,
mutations are introduced occasionally to provide for random variation. Parents
and children compete to be included in the next generation. As the generations
progress, the random designs converge to a design that has the best fitness.</p><sec sec-type="subsection" id="subsec4.1"><title>4.1. Genetic Algorithm Cycle</title><p>The genetic algorithm cycle used to optimize
the magnitude coefficients of <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M67"><mml:mrow><mml:mover><mml:mrow><mml:mi mathvariant="bold">H</mml:mi></mml:mrow><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>z</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> can be
broken down into nine steps. A brief description of each step is now given. It
should be noted that other GA&#x2019;s with different cost functions could be investigated.
The purpose of this work is to present one such GA and compare the results to
other easily implemented techniques.</p><statement id="head1"><title>(1) Determine a Coding for the Design</title><p>Each design in a
GA consists of a number of independent variables chosen by the designer. Each
independent variable is called a &#x201c;gene,&#x201d; a set of genes giving one design, or &#x201c;chromosome.&#x201d;
As the desired result of the algorithm was to obtain an optimized impulse
response model, <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M68"><mml:mrow><mml:mover><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>, that could
be used in physical experimentation, a 128 or 256 coefficient <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M69"><mml:mrow><mml:mover><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> for the mock
cabin described in Section <xref ref-type="sec" rid="sec6">6</xref> was obtained by the SysID process described in
Section <xref ref-type="sec" rid="subsec2.1">2.1</xref>. The FFT of <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M70"><mml:mrow><mml:mover><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> was then
taken, and the phase information of <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M71"><mml:mrow><mml:mover><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>z</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> was preserved
in a vector. The magnitude information of <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M72"><mml:mrow><mml:mover><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>z</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> was
discarded, as the GA was implemented to find the optimal magnitude coefficients
by making each unknown magnitude coefficient a gene. Each design then contained
64 or 128 genes, which were the unknown 128 or 256 magnitude coefficients of <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M73"><mml:mrow><mml:mover><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>z</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> (since they
are mirrored about the Nyquist frequency).</p></statement><statement id="head2"><title>(2) Generate an Initial Population</title><p>Once the coding
scheme for a single design was established, a population of N designs was
randomly generated. This was done by randomly assigning a value between a
minimum value of  0.01 and a maximum of 10 for each gene (magnitude coefficient)
in the design. This range was chosen based on some trial and error. If the
minimum was set to zero, the GA would make all the magnitude coefficients zero
giving a trivial solution of all zero eigenvalues. The maximum value was set to
10 so that the generated designs were close to the overall magnitude values for
the original model. The process was repeated N times to generate the entire
population. In general, designs with many genes require large population sizes
to maintain adequate diversity. The population size was 500.</p></statement><statement id="head3"><title>(3) Calculate Fitness for Each Design</title><p>After the initial
population was randomly generated, each design was evaluated and assigned a
fitness value. Each randomly generated set of magnitude coefficients was
recombined with the stored phase information, and the inverse FFT was taken to
get a new unique model for the impulse response, <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M74"><mml:mrow><mml:mover><mml:mrow><mml:mi mathvariant="bold">h</mml:mi></mml:mrow><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>. This new
model was used to compute the eigenvalues of the filtered-x autocorrelation
matrix in the same manner as explained in Section <xref ref-type="sec" rid="sec4">4</xref>. For swept tone noise,
the  eigenvalues were computed over a
specified frequency range and then normalized by the largest of the
eigenvalues. As the ideal normalized eigenvalue at each frequency would be one,
the fitness value was chosen as a sum of the squared errors between the actual
value of each eigenvalue in the frequency range and one, as shown in (<xref ref-type="disp-formula" rid="eq4">4</xref>):</p></statement><p><disp-formula id="eq4"><label>(4)</label><mml:math altimg="C:\WINDOWS\Temp\MMLIMG8643.png" width="164" height="57" xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M75"><mml:mrow><mml:mtext>fitness</mml:mtext><mml:mo>=</mml:mo><mml:munderover><mml:mstyle displaystyle="true"><mml:mo>&#x2211;</mml:mo></mml:mstyle><mml:mrow><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mtext>start</mml:mtext></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mtext>end</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:mo minsize="0.75em" maxsize="0.75em">(</mml:mo><mml:mn>1</mml:mn><mml:mo>&#x2212;</mml:mo><mml:msub><mml:mrow><mml:mi>&#x3bb;</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:msup><mml:mrow><mml:mo minsize="0.75em" maxsize="0.75em">)</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow><mml:mn>.</mml:mn></mml:mrow></mml:math></disp-formula>
The fitness value for multiple tone
noise was simply the span (<inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M76"><mml:mrow><mml:msub><mml:mrow><mml:mi>&#x3bb;</mml:mi></mml:mrow><mml:mrow><mml:mi>max</mml:mi><mml:mo>&#x2009;</mml:mo></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> divided by <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M77"><mml:mrow><mml:msub><mml:mrow><mml:mi>&#x3bb;</mml:mi></mml:mrow><mml:mrow><mml:mi>min</mml:mi><mml:mo>&#x2009;</mml:mo></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>) of all
nonzero eigenvalues.</p><p>In addition, a
penalty was applied to any design whose phase response was in error by more
than 40<sup><italic>&#x2da;</italic></sup> in a range of +/&#x2212; 5&#x2009;Hz around each of the tonal frequencies in the
multiple tone noise. This was done to decrease the design&#x2019;s sensitivity to
tonal frequencies shifting. Constraining the phase in this way ensures that the
algorithm will remain stable for small changes in the tonal frequencies.
Designs whose performance would be hindered by the phase error introduced by
altering the magnitude response were assigned a poor fitness value.</p><statement id="head4"><title>(4) Selection of Parents</title><p>A tournament
selection process was used to choose parent designs from the population. A
specified number of designs were randomly selected to compete in the
tournament. The design with the best fitness wins the tournament and was made a
parent design. This process was repeated until enough parents had been selected
to make N children; a set of two parent designs producing a single-child
design.</p></statement><statement id="head5"><title>(5) Perform Crossover</title><p>A process called
crossover exchanged traits from each parent design and created children
designs. In this way, new designs were made that had traits from each parent.
For this work, blend crossover was used. In blend crossover, genes from both parents
are blended to make two new children genes. This occurs gene by gene. First, a
random number between zero and one is chosen for each gene to determine whether
crossover will occur. If the random number is larger than the user defined
crossover probability, no crossover occurs. The genes for the children, <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M78"><mml:mrow><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M79"><mml:mrow><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, are equal to the parent genes, <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M80"><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M81"><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, respectively, so that if no crossover occurs for any genes in the design, the
children will be identical to the parents. If the random number is less than
the user specified crossover probability, another random number is chosen. If
it is &#x3c;0.5, the blend parameter, <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M82"><mml:mrow><mml:mi>a</mml:mi></mml:mrow></mml:math></inline-formula>,
is calculated by</p></statement><p><disp-formula id="eq5"><label>(5)</label><mml:math altimg="C:\WINDOWS\Temp\MMLIMG8651.png" width="93" height="66" xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M83"><mml:mrow><mml:mi>a</mml:mi><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mrow><mml:mo minsize="0.75em" maxsize="0.75em">(</mml:mo><mml:mn>2</mml:mn><mml:mi>r</mml:mi><mml:msup><mml:mrow><mml:mo minsize="0.75em" maxsize="0.75em">)</mml:mo></mml:mrow><mml:mrow><mml:mn>1</mml:mn><mml:mo>/</mml:mo><mml:mi>&#x3b7;</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula>
and if the random number is &#x2265;0.5,
the blend parameter is <disp-formula id="eq6"><label>(6)</label><mml:math altimg="C:\WINDOWS\Temp\MMLIMG8652.png" width="143" height="66" xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M84"><mml:mrow><mml:mi>a</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>&#x2212;</mml:mo><mml:mfrac><mml:mrow><mml:mrow><mml:mo minsize="0.75em" maxsize="0.75em">(</mml:mo><mml:mn>2</mml:mn><mml:mo>&#x2212;</mml:mo><mml:mn>2</mml:mn><mml:mi>r</mml:mi><mml:msup><mml:mrow><mml:mo minsize="0.75em" maxsize="0.75em">)</mml:mo></mml:mrow><mml:mrow><mml:mn>1</mml:mn><mml:mo>/</mml:mo><mml:mi>&#x3b7;</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac><mml:mn>.</mml:mn></mml:mrow></mml:math></disp-formula> The children genes <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M85"><mml:mrow><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M86"><mml:mrow><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> are created from the parent genes <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M87"><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M88"><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> by <disp-formula id="eq7"><label>(7)</label><mml:math altimg="C:\WINDOWS\Temp\MMLIMG8657.png" width="192" height="78" xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M89"><mml:mrow><mml:mtable width="auto" columnalign="left" class="split"><mml:mtr><mml:mtd columnalign="right"><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mtd><mml:mtd columnalign="left"><mml:mo>=</mml:mo><mml:mrow><mml:mo minsize="0.75em" maxsize="0.75em">(</mml:mo><mml:mi>a</mml:mi><mml:mo minsize="0.75em" maxsize="0.75em">)</mml:mo></mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mrow><mml:mo minsize="0.75em" maxsize="0.75em">(</mml:mo><mml:mn>1</mml:mn><mml:mo>&#x2212;</mml:mo><mml:mi>a</mml:mi><mml:mo minsize="0.75em" maxsize="0.75em">)</mml:mo><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="right"><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mtd><mml:mtd columnalign="left"><mml:mo>=</mml:mo><mml:mrow><mml:mo minsize="0.75em" maxsize="0.75em">(</mml:mo><mml:mn>1</mml:mn><mml:mo>&#x2212;</mml:mo><mml:mi>a</mml:mi><mml:mo minsize="0.75em" maxsize="0.75em">)</mml:mo></mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mo minsize="0.75em" maxsize="0.75em">(</mml:mo><mml:mi>a</mml:mi><mml:mo minsize="0.75em" maxsize="0.75em">)</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mn>.</mml:mn></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math></disp-formula></p><p>The value of <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M90"><mml:mrow><mml:mi>&#x3b7;</mml:mi></mml:mrow></mml:math></inline-formula> is chosen by
the user. As <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M91"><mml:mrow><mml:mi>&#x3b7;</mml:mi><mml:mo>&#x2192;</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula>,
the crossover becomes uniform, meaning that <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M92"><mml:mrow><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M93"><mml:mrow><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>. As <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M94"><mml:mrow><mml:mi>&#x3b7;</mml:mi><mml:mo>&#x2192;</mml:mo><mml:mi>&#x221e;</mml:mi></mml:mrow></mml:math></inline-formula>, <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M95"><mml:mrow><mml:mi>a</mml:mi><mml:mo>&#x2192;</mml:mo><mml:mn>1</mml:mn><mml:mo>/</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:math></inline-formula> and the children&#x2019;s genes are the average of
the parent&#x2019;s gene values.</p><p>The crossover
probability was chosen to be 50&#x25; and <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M96"><mml:mrow><mml:mi>&#x3b7;</mml:mi></mml:mrow></mml:math></inline-formula>
was 0.5.</p><statement id="head6"><title>(6) Perform Mutation</title><p>After crossover,
some of the genes in the children designs are mutated. Mutation provides for
diversity and occasionally introduces new beneficial information into a design.
Higher mutation probability maintains more diversity in the designs as the
generations progress and can help the algorithm avoid converging on a local
optimum in the design space. Mutation can be made dynamic allowing for high
diversity initially, keeping the algorithm from settling prematurely in a local
optimum. In later generations, mutation is constrained allowing the algorithm
to randomly make fine adjustments to the design once it is near what is hoped
to be the global optimum. Initially, mutation can cause the gene to become any
value in the allowable range for that gene. By the last generation, when
mutation occurs the new value for the gene is only allowed to have a new value
that is very close to the original. The probability of mutation occurring does
not change, only how different the mutated gene is allowed to be from its
premutation value. This is done by introducing a dynamic mutation parameter <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M97"><mml:mrow><mml:mi>&#x3b1;</mml:mi></mml:mrow></mml:math></inline-formula>: <disp-formula id="eq8"><label>(8)</label><mml:math altimg="C:\WINDOWS\Temp\MMLIMG8666.png" width="122" height="43" xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M98"><mml:mrow><mml:mi>&#x3b1;</mml:mi><mml:mo>=</mml:mo><mml:mrow><mml:mo minsize="1.5em" maxsize="1.5em">(</mml:mo><mml:mn>1</mml:mn><mml:mo>&#x2212;</mml:mo><mml:mfrac><mml:mrow><mml:mi>n</mml:mi><mml:mo>&#x2212;</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>N</mml:mi></mml:mrow></mml:mfrac><mml:msup><mml:mrow><mml:mo minsize="1.5em" maxsize="1.5em">)</mml:mo></mml:mrow><mml:mrow><mml:mi>&#x3b2;</mml:mi></mml:mrow></mml:msup><mml:mo>,</mml:mo></mml:mrow></mml:mrow></mml:math></disp-formula> where <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M99"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:math></inline-formula> is the current generation
number and <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M100"><mml:mrow><mml:mi>N</mml:mi></mml:mrow></mml:math></inline-formula> is the total number of generations. The exponent, <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M101"><mml:mrow><mml:mi>&#x3b2;</mml:mi></mml:mrow></mml:math></inline-formula>, is a user defined parameter that
weights the dynamic function of <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M102"><mml:mrow><mml:mi>&#x3b1;</mml:mi></mml:mrow></mml:math></inline-formula>. If <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M103"><mml:mrow><mml:mi>&#x3b2;</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula>, <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M104"><mml:mrow><mml:mi>&#x3b1;</mml:mi></mml:mrow></mml:math></inline-formula> will always be one and the amount of mutation allowed will be uniform
for all generations. If <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M105"><mml:mrow><mml:mi>&#x3b2;</mml:mi></mml:mrow></mml:math></inline-formula> is greater
than zero, the amount of mutation allowed decreases as the generation number
increases.</p></statement><p>A random number is
chosen to determine whether mutation will occur for each child gene. If the
random number is less than the user-specified mutation probability, another
random number, <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M106"><mml:mrow><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mtext>mut</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>, is chosen within the allowable range for that
gene. If <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M107"><mml:mrow><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mtext>mut</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> is less than the current value for the gene, the new
gene value is <disp-formula id="eq9"><label>(9)</label><mml:math altimg="C:\WINDOWS\Temp\MMLIMG8676.png" width="333" height="58" xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M108"><mml:mrow><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mtext>new</mml:mtext></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mi>min</mml:mi><mml:mo>&#x2009;</mml:mo></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mo minsize="1em" maxsize="1em">(</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mtext>mut</mml:mtext></mml:mrow></mml:msub><mml:mo>&#x2212;</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mi>min</mml:mi><mml:mo>&#x2009;</mml:mo></mml:mrow></mml:msub><mml:msup><mml:mrow><mml:mo minsize="1em" maxsize="1em">)</mml:mo></mml:mrow><mml:mrow><mml:mi>&#x3b1;</mml:mi></mml:mrow></mml:msup><mml:mrow><mml:mo minsize="1em" maxsize="1em">(</mml:mo><mml:mi>c</mml:mi><mml:mo>&#x2212;</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mi>min</mml:mi><mml:mo>&#x2009;</mml:mo></mml:mrow></mml:msub><mml:msup><mml:mrow><mml:mo minsize="1em" maxsize="1em">)</mml:mo></mml:mrow><mml:mrow><mml:mo minsize="0.75em" maxsize="0.75em">(</mml:mo><mml:mn>1</mml:mn><mml:mo>&#x2212;</mml:mo><mml:mi>&#x3b1;</mml:mi><mml:mo minsize="0.75em" maxsize="0.75em">)</mml:mo></mml:mrow></mml:msup></mml:mrow><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula> and if <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M109"><mml:mrow><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mtext>mut</mml:mtext></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula> is greater
than the current value for the gene, the new gene value is <disp-formula id="eq10"><label>(10)</label><mml:math altimg="C:\WINDOWS\Temp\MMLIMG8678.png" width="347" height="58" xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M110"><mml:mrow><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mtext>new</mml:mtext></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mi>max</mml:mi><mml:mo>&#x2009;</mml:mo></mml:mrow></mml:msub><mml:mo>&#x2212;</mml:mo><mml:mo minsize="1em" maxsize="1em">(</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mi>max</mml:mi><mml:mo>&#x2009;</mml:mo></mml:mrow></mml:msub><mml:mo>&#x2212;</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mstyle><mml:mrow><mml:mtext>mut</mml:mtext></mml:mrow></mml:mstyle><mml:mo>&#x2009;</mml:mo></mml:mrow></mml:msub><mml:msup><mml:mrow><mml:mo minsize="1em" maxsize="1em">)</mml:mo></mml:mrow><mml:mrow><mml:mi>&#x3b1;</mml:mi></mml:mrow></mml:msup><mml:mrow><mml:mo minsize="1em" maxsize="1em">(</mml:mo><mml:msub><mml:mrow><mml:mi>c</mml:mi></mml:mrow><mml:mrow><mml:mi>max</mml:mi><mml:mo>&#x2009;</mml:mo></mml:mrow></mml:msub><mml:mo>&#x2212;</mml:mo><mml:mi>c</mml:mi><mml:msup><mml:mrow><mml:mo minsize="1em" maxsize="1em">)</mml:mo></mml:mrow><mml:mrow><mml:mo minsize="0.75em" maxsize="0.75em">(</mml:mo><mml:mn>1</mml:mn><mml:mo>&#x2212;</mml:mo><mml:mi>&#x3b1;</mml:mi><mml:mo minsize="0.75em" maxsize="0.75em">)</mml:mo></mml:mrow></mml:msup></mml:mrow><mml:mn>.</mml:mn></mml:mrow></mml:math></disp-formula></p><p>The mutation
probability was chosen to be 50&#x25; and <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M111"><mml:mrow><mml:mi>&#x3b2;</mml:mi></mml:mrow></mml:math></inline-formula> was set to 0.5.</p><statement id="head7"><title>(7) Measure Fitness of Children</title><p>Once all of the
children were created through crossover and mutation, the fitness value of each
child was computed in the same way as described in Step 3.</p></statement><statement id="head8"><title>(8) Perform Elitism</title><p>Once each child
design has a fitness value, parents are made to compete with children in a
process called elitism. All of the parents and children are sorted by their
fitness value, and the N number of designs with the best fitness value becomes
the starting generation for the next iteration of the algorithm.</p></statement><statement id="head9"><title>(9) Repeat Steps 4&#x2013;8 for <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M112"><mml:mrow><mml:mi>M</mml:mi></mml:mrow></mml:math></inline-formula> Number of Generations</title><p>Steps 4&#x2013;8 were
repeated for M number of generations. The number of generations needed to be
large enough to allow the algorithm to converge on an optimum design.  For the work reported here, M was chosen to
be in the range of 50&#x2013;200.</p></statement><p>The optimization
performed by the genetic algorithm is all done offline as part of the setup of
the ANC system after the offline system identification routine. It is not run
in real-time and so is currently limited to use with systems where the
secondary path does not change significantly and can be characterized offline.</p></sec><sec sec-type="subsection" id="subsec4.2"><title>4.2. Genetic Algorithm Results</title><statement id="head10"><title>(1) Swept Tone Noise</title><p>The GA was unable
to produce a design that had lower eigenvalue span than the flattened magnitude
design when optimizing for the entire range of frequencies from 0&#x2013;400&#x2009;Hz. There
were not enough degrees of freedom in the design variables to get a better
result. The frequency range for swept tone noise was reduced to a much smaller
range to see if the genetic algorithm could improve the span of the eigenvalues
in a smaller range. The GA was run for swept tone noise in the range 60&#x2013;90&#x2009;Hz with 128
filter coefficients. The results for 60&#x2013;90&#x2009;Hz are shown
in Figures <xref ref-type="fig" rid="fig6">6</xref> and <xref ref-type="fig" rid="fig7">7</xref>. Figure <xref ref-type="fig" rid="fig6">6</xref> shows the original- and new-modified magnitude
coefficients, and Figure <xref ref-type="fig" rid="fig7">7</xref> shows the resulting eigenvalues. As before, the
eigenvalues in both the original and modified case have been normalized by the
largest of the original eigenvalues. The eigenvalues from the genetically
optimized magnitude coefficients are more uniform. The eigenvalue span for the
genetic algorithm model approach was 1.08, which is improved over both the
eigenvalue span of 4.578 and 2.45 from the original and the flattened models,
respectively.</p></statement><fig id="fig6"><label>Figure 6</label><caption><p>Original and modified magnitude coefficients of <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M113"><mml:mrow><mml:mover><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>z</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> for genetic
algorithm run from 60&#x2013;90&#x2009;Hz.</p></caption><graphic xlink:href="791050.fig.006" /></fig><fig id="fig7"><label>Figure 7</label><caption><p>Normalized original and modified eigenvalues 
for genetic algorithm run from 60&#x2013;90&#x2009;Hz.</p></caption><graphic xlink:href="791050.fig.007" /></fig><statement id="head11"><title>(2) Multiple Tone Noise</title><p>The GA was also
run for the reference signal containing six offbin tones, as described in Section
<xref ref-type="sec" rid="subsec4.2">4.2</xref>, for 128 and 256 filter coefficients. The genetic algorithm was able to
find a magnitude response that is unlike the X-inverse model and reduces the
eigenvalue span to 5.8 for 128 coefficients and 5.3 for 256 coefficients.  These values can be compared to the results
for the other methods shown in Table <xref ref-type="table" rid="tab1">1</xref>, which have span values typically several
orders of magnitude higher. Figure <xref ref-type="fig" rid="fig8">8</xref> shows the fitness history of the best
design in each generation of the 128-coefficient optimization and gives an idea
of the dynamics of the genetic optimization. The fitness is the span plotted on
a logarithmic scale.</p></statement><fig id="fig8"><label>Figure 8</label><caption><p>Fitness history for
genetic optimization of 128-coefficient Sys ID model.</p></caption><graphic xlink:href="791050.fig.008" /></fig><p>The optimized magnitude coefficients
found by the genetic algorithm are specific to the noise problem given to the
genetic algorithm. If the tones shift in frequency or change in amplitude, the
result is no longer guaranteed to be an optimum result. To see how sensitive
the genetic algorithm model is to shifts in the tonal frequencies, the
eigenvalue span for reference signals with all tones shifted by +/&#x2212; 2&#x2009;Hz up to
+/&#x2212; 10&#x2009;Hz was calculated. This is compared to the original model in Table <xref ref-type="table" rid="tab2">2</xref>. In
general, the farther the tones get from the frequencies for which the magnitude
was optimized, the worse the span gets. It is difficult to predict how
sensitive a genetic model will be for any given application without first
performing the optimization. The sensitivity will depend on how much the magnitude
response of the genetic model varies near the frequencies for which it was
optimized. The phase is guaranteed to be within acceptable error +/&#x2212; 5&#x2009;Hz from
the tonal frequencies by the GA and so the design remains robust in terms of
stability for changes within this range. Where more shift in the tones is
anticipated the GA can be constrained accordingly. The magnitude of both the
original and genetic 128-coefficient models is plotted together in Figure <xref ref-type="fig" rid="fig9">9</xref>
along with the phase error in the genetic model (difference between the two).</p><table-wrap id="tab2"><label>Table 2</label><caption><p>Comparison of eigenvalue span for original and GA magnitude coefficients for offbin tones shifted in frequency from the values for which the GA optimized the model.</p></caption><table><thead><tr><th align="left" /><th align="center">f shift</th><th align="center">&#x2212;10</th><th align="center">&#x2212;6</th><th align="center">&#x2212;4</th><th align="center">&#x2212;2</th><th align="center">0</th><th align="center">2</th><th align="center">4</th><th align="center">6</th><th align="center">10</th></tr></thead><tbody><tr><td align="left" rowspan="2">
Original model</td><td align="center">128 span</td><td align="center">193.5</td><td align="center">209.3</td><td align="center">217.5</td><td align="center">220.7</td><td align="center">216.8</td><td align="center">213</td><td align="center">201.1</td><td align="center">202.2</td><td align="center">392.7</td></tr><tr><td align="center">256 span</td><td align="center">64.4</td><td align="center">265.5</td><td align="center">444.0</td><td align="center">361.7</td><td align="center">238.5</td><td align="center">169.6</td><td align="center">174.8</td><td align="center">500.0</td><td align="center">1240.1</td></tr><tr><td align="left" rowspan="2">Genetic model</td><td align="center">128 span</td><td align="center">9.0</td><td align="center">5.1</td><td align="center">4.3</td><td align="center">5.0</td><td align="center">5.8</td><td align="center">7.6</td><td align="center">9.9</td><td align="center">12.8</td><td align="center">24.4</td></tr><tr><td align="center">256 span</td><td align="center">23.9</td><td align="center">11.3</td><td align="center">28.2</td><td align="center">13.0</td><td align="center">5.3</td><td align="center">12.9</td><td align="center">51.4</td><td align="center">132.0</td><td align="center">1309.2</td></tr></tbody></table></table-wrap><fig-group id="fig9"><caption><p>Magnitude
of original and genetic 128-coefficient models along with the phase error in
the genetic model.</p></caption><fig id="fig9a"><label>(a)</label><graphic xlink:href="791050.fig.009a" /></fig><fig id="fig9b"><label>(b)</label><graphic xlink:href="791050.fig.009b" /></fig></fig-group></sec></sec><sec sec-type="section" id="sec5"><title>5. Experimental Results</title><p>Experiments were
performed to verify that the reduction in eigenvalue span demonstrated in Section
<xref ref-type="sec" rid="sec4">4</xref> also leads to better ANC performance. First, the experimental setup will be
explained, then ANC results for swept sine noise over the three ranges (60&#x2013;90&#x2009;Hz, 90&#x2013;120&#x2009;Hz, and 120&#x2013;150&#x2009;Hz) and for multiple tone noise (at offbin
frequencies) will be shown.</p><sec sec-type="subsection" id="subsec5.1"><title>5.1. Experimental Setup</title><p>The experiments
were conducted inside a mock cabin enclosure with nominal dimensions of 1.0 m &#xd7;
1.5 m &#xd7; 1.1&#x2009;m. The cabin has a steel frame, 0.01&#x2009;m thick plywood sides, and a
0.003 m thick Plexiglas front panel. A speaker placed under a chair served as
the primary sound source, and two loudspeakers were setup in a single channel
control configuration. A crossover circuit routed the low-frequency content
(below 90&#x2009;Hz) to a subwoofer on the floor of the cab, and the high-frequency
content (above 90&#x2009;Hz) to a satellite speaker mounted in the top corner of the
cab, near the back. An error microphone was placed on the ceiling near where an
operator&#x2019;s head would be. The performance of the algorithms will be reported at
the error sensor. Figure <xref ref-type="fig" rid="fig10">10</xref> shows the cab, error sensor, and speakers.</p><fig id="fig10"><label>Figure 10</label><caption><p>Photo of inside of mock cab.</p></caption><graphic xlink:href="791050.fig.010" /></fig><p>The
adaptive control filter consisted of 32 taps for swept tone noise and 100 taps
for multiple tone noise. Secondary path transfer functions were modeled with
either 128 or 256 taps. The convergence coefficient, <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M114"><mml:mrow><mml:mi>&#x3bc;</mml:mi></mml:mrow></mml:math></inline-formula>, was determined
experimentally by finding the largest stable value for the noise signal under
test and then scaling it back by a factor of ten to ensure stability. All input
channels were simultaneously sampled at 2&#x2009;kHz, and all input and output signals
had 16&#x2009;bits of resolution. Fourth-order Butterworth low-pass filters (400&#x2009;Hz
cutoff) provided antialiasing and reconstruction of input and output signals,
respectively.</p></sec><sec sec-type="subsection" id="subsec5.2"><title>5.2. Experimental Results&#x2014;Swept Tone Noise</title><p>Each  <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M115"><mml:mrow><mml:mover><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> model was
tested for swept tone noise over the frequency ranges 60&#x2013;90&#x2009;Hz, 90&#x2013;120&#x2009;Hz, and 120&#x2013;150&#x2009;Hz. A test
signal was created for each frequency range that consisted of a sine wave being
swept up and down over the frequency range at a rate of 2&#x2009;Hz/sec. The
time-averaged sound pressure level (SPL) over the entire duration of the test
signal was measured with and without control running. Each measurement was
performed three times for computation of an average and to give a sense of the
measurement&#x2019;s reproducibility. The attenuation (the difference in SPL with
control off and on) using all three  <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M116"><mml:mrow><mml:mover><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> models is
shown in Table <xref ref-type="table" rid="tab3">3</xref>. The &#x201c;reproducibility&#x201d; shown in Table <xref ref-type="table" rid="tab3">3</xref> was calculated in the
same manner as a standard deviation, although it is recognized that the small
sample size precludes referring to the result as a statistically valid standard
deviation.</p><table-wrap id="tab3"><label>Table 3</label><caption><p>Comparison of control performance using original, flattened, and genetic <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M117"><mml:mrow><mml:mover><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> models for swept tone noise.</p></caption><table><thead><tr><th align="left">Frequency</th><th align="center">Type of</th><th align="center"><inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M118"><mml:mrow><mml:mi>&#x3bc;</mml:mi></mml:mrow></mml:math></inline-formula></th><th align="center">Error Mic</th><th align="center">Reproducibility</th><th align="center">Additional reduction</th></tr><tr><th align="left">range</th><th align="center"><inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M119"><mml:mrow><mml:mover><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> model</th><th align="center"><inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M120"><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mn>0.1</mml:mn></mml:mrow><mml:mrow><mml:mo>&#x2a;</mml:mo></mml:mrow></mml:msup><mml:msub><mml:mrow><mml:mi>&#x3bc;</mml:mi></mml:mrow><mml:mrow><mml:mi>max</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula></th><th align="center">avg. reduction (dB)</th><th align="center">(dB)</th><th align="center">compared to original
 (in dB)</th></tr></thead><tbody><tr><td align="left" rowspan="3">60&#x2013;90&#x2009;Hz</td><td align="center">Original</td><td align="center">1e-8</td><td align="center">14.8</td><td align="center">0.16</td><td align="center" /></tr><tr><td align="center">Flattened</td><td align="center">3e-8</td><td align="center">21.9</td><td align="center">0.37</td><td align="center">7.1</td></tr><tr><td align="center">Genetic</td><td align="center">5e-8</td><td align="center">20.8</td><td align="center">0.17</td><td align="center">6.0</td></tr></tbody></table></table-wrap><p>In
the range from 60&#x2013;90&#x2009;Hz, the SPL
before running control was about 95&#x2009;dB (computed over the entire frequency
range) and about 73&#x2009;dB with control for the flattened magnitude model.  Figure <xref ref-type="fig" rid="fig11">11</xref> shows a plot of the frequency
spectrum for both control on and control off for the 60&#x2013;90&#x2009;Hz range.</p><fig id="fig11"><label>Figure 11</label><caption><p>Sound pressure level (SPL) at the error sensor for 60&#x2013;90&#x2009;Hz.</p></caption><graphic xlink:href="791050.fig.011" /></fig><p>The
data show that control with the genetic and the flattened models significantly
outperformed control with the original <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M121"><mml:mrow><mml:mover><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> model. For
the range 60&#x2013;90&#x2009;Hz, control
with the genetic and flattened models outperformed the original control by 6-7&#x2009;dB, with
control with the flattened model providing 1&#x2009;dB more control than the genetic
model. Experiments for other frequency ranges were also done with similar
results.</p></sec><sec sec-type="subsection" id="subsec5.3"><title>5.3. Experimental Results&#x2014;Multiple Tone Noise</title><p>Multiple tone
noise ANC experiments in the mock cab were done using 128 and 256-coefficient
original, X-inverse, and genetic secondary path models with the reference
signal consisting of multiple offbin frequency tones, as described in Section
<xref ref-type="sec" rid="subsec4.2">4.2</xref>. For these tests, three 10-second time records of the error signal were
taken as follows:</p><p><list><list-item><label>(1)</label><p>stationary error signal with control off;</p></list-item><list-item><label>(2)</label><p>converging error signal from the time
control was turned on;</p></list-item><list-item><label>(3)</label><p>stationary error signal after the
algorithm had converged to its eventual steady state level.</p></list-item></list></p><p>The measured
performance for each test case was the eventual amount of attenuation (in dB)
at the error sensor, calculated from the first and third time records and the
convergence time in seconds from the second-time record. The convergence time
was taken to be a measure of how long it took the error signal, from the time
that control was enabled, to reach <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M122"><mml:mrow><mml:mn>1</mml:mn><mml:mo>/</mml:mo><mml:mi>e</mml:mi></mml:mrow></mml:math></inline-formula> of its initial value (about 9&#x2009;dB
attenuation), where <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M123"><mml:mrow><mml:mi>e</mml:mi></mml:mrow></mml:math></inline-formula> is the base of the natural logarithm. The reason for
choosing this was that the convergence time essentially becomes a measure of
the rate of attenuation, which was felt to be useful when comparing cases where
the overall level of attenuation may be significantly different. These results
are summarized in Table <xref ref-type="table" rid="tab4">4</xref>. When a signal did not converge to <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M124"><mml:mrow><mml:mn>1</mml:mn><mml:mo>/</mml:mo><mml:mi>e</mml:mi></mml:mrow></mml:math></inline-formula> of its initial value during the second-time
capture, it is reported as 10+ seconds. The actual convergence time for these
measurements was not calculated. The genetic models for both 128 and 256
coefficients were better than both the original and X-inverse models for both
measures of performance. Models that gave lower eigenvalue span performed
better with the exception of the 128-coefficient X-inverse model whose
performance was worse than expected.</p><table-wrap id="tab4"><label>Table 4</label><caption><p>Comparison of control performance using original, X-inverse, and genetic <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M125"><mml:mrow><mml:mover><mml:mrow><mml:mi>h</mml:mi></mml:mrow><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> models for multiple tone noise.</p></caption><table><thead><tr><th align="left" rowspan="2">Sys ID type</th><th align="center">Convergence time </th><th align="center">Eventual reduction </th><th align="center">Eignvalue</th></tr><tr><th align="center">(sec)</th><th align="center">(dB)</th><th align="center">span</th></tr></thead><tbody><tr><td align="left">Normal 128</td><td align="center">3.9</td><td align="center">&#x2212;19.5</td><td align="center">217</td></tr><tr><td align="left">Normal 256</td><td align="center">6.3</td><td align="center">&#x2212;16.9</td><td align="center">239</td></tr><tr><td align="left">X-inverse 128</td><td align="center">10+</td><td align="center">&#x2212;4.6</td><td align="center">16</td></tr><tr><td align="left">X-inverse 256</td><td align="center">10+</td><td align="center">&#x2212;2.6</td><td align="center">991</td></tr><tr><td align="left">Genetic 128</td><td align="center">1</td><td align="center">&#x2212;25.9</td><td align="center">2.3</td></tr><tr><td align="left">Genetic 256</td><td align="center">2.2</td><td align="center">&#x2212;26.1</td><td align="center">2.4</td></tr></tbody></table></table-wrap><p>Based
on the eigenvalue span, the 128 coefficient X-inverse model should have been a
significant improvement over the original model. The reason for the poor
performance is a result of phase errors introduced by modifying the magnitude
values. As for the magnitude coefficients, preserving the phase coefficients
guarantees the phase response will be the same at frequency bins, but changing
the magnitude coefficients does have an influence on the response in between
these bins. As noted previously, as long as the phase response modeled by the
secondary path estimate is within 90<sup><italic>&#x2da;</italic></sup> of the true phase response, the algorithm
will be stable. Comparing the zero-padded phase response for the original 128-coefficient
model and the X-inverse model reveals that the phase difference between the two
at 100&#x2009;Hz (one of the tonal frequencies) approaches that limit. While the
errors in the original model of the secondary path are not known, it is assumed
that it is a better estimate and the X-inverse model deviating from it by close
to 90<sup><italic>&#x2da;</italic></sup> is the cause for the poor performance.</p><p>Figure <xref ref-type="fig" rid="fig12">12</xref> shows learning curves for the individual tones in the multitone test case
for the 128-coefficient model. These are slices along tonal frequencies from a
spectrogram of the converging error signal. These plots show the different
rates of convergence for the individual tones in the noise. The genetic model
converges faster and to a lower level than the other models at all tones except
280&#x2009;Hz where performance is similar for the original model. This is the fastest
converging mode for the algorithm for all secondary path models. The X-inverse
model shows that the 180&#x2009;Hz tone is diverging due to the &#x3e;90<sup><italic>&#x2da;</italic></sup> phase error
at that frequency (see Figure <xref ref-type="fig" rid="fig5">5</xref>).</p><fig-group id="fig12"><caption><p>Learning curves for individual tones of multiple noise test case for 128-coefficient
original, X-inverse, and genetic models.</p></caption><fig><graphic xlink:href="791050.fig.012a" /></fig><fig><graphic xlink:href="791050.fig.012b" /></fig></fig-group></sec></sec><sec sec-type="section" id="sec6"><title>6. Conclusions</title><p>Use of a genetic
algorithm to find optimum values for the magnitude coefficients of the
secondary path estimate for the FXLMS algorithm while preserving the phase of <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M126"><mml:mrow><mml:mover><mml:mrow><mml:mi mathvariant="bold">H</mml:mi></mml:mrow><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>z</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> has been
shown to reduce the variation in the eigenvalues of the filtered-x
autocorrelation matrix.</p><p>ANC
in a mock cab using control with both the flattened and genetic <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M127"><mml:mrow><mml:mover><mml:mrow><mml:mi mathvariant="bold">h</mml:mi></mml:mrow><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> models
provided as much as 6-7&#x2009;dB additional
attenuation over control with the original <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M128"><mml:mrow><mml:mover><mml:mrow><mml:mi mathvariant="bold">h</mml:mi></mml:mrow><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> model.
For these specific swept tone noise tests, the genetically optimized <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M129"><mml:mrow><mml:mover><mml:mrow><mml:mi mathvariant="bold">h</mml:mi></mml:mrow><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> algorithm
did not provide any additional benefit over the flattened model, even though
the eigenvalues were more uniform. It is possible that the improved eigenvalues
resulting from the genetically optimized model could lead to better performance
in other applications.</p><p>When
considering the more general case for multiple tone noise, with tonal
frequencies not corresponding exactly to frequency bins, control with the X-inverse <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M130"><mml:mrow><mml:mover><mml:mrow><mml:mi mathvariant="bold">h</mml:mi></mml:mrow><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> models
performed worse than the original <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M131"><mml:mrow><mml:mover><mml:mrow><mml:mi mathvariant="bold">h</mml:mi></mml:mrow><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> model.
Genetic <inline-formula><mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML" id="M132"><mml:mrow><mml:mover><mml:mrow><mml:mi mathvariant="bold">h</mml:mi></mml:mrow><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> models
were shown to give 6&#x2013;9&#x2009;dB additional
attenuation with faster convergence times.</p><p>Use
of a genetic algorithm as an optimization method in implementing the EE-FXLMS
algorithm extends its utility and increases the potential benefit of its use
over the FXLMS algorithm. With this method, the eigenvalue disparity can be
reduced while assuring performance limiting phase errors are not introduced.</p><p>The optimization
performed on the secondary path estimate in the EE-FXLMS algorithm in this
paper is limited to applications where the secondary path model (at least the
phase response) is relatively stable since the secondary path is only
characterized and optimization performed as part of the setup of an ANC system.
Further work could be done to implement the EE-FXLMS with genetic optimization
for a changing secondary path with an online Sys ID routine [<xref ref-type="bibr" rid="B14">14</xref>]. The secondary
path can be characterized online periodically and the eigenvalue equalization performed
in the background while control is running. Everytime a newly optimized
secondary path model becomes available, it can be updated and used to run
control. The time it would take to get a new-optimized model for the secondary
path estimate would be set by the time it takes for the genetic algorithm to
execute.</p></sec></body><back><ref-list><ref id="B1" content-type="article"><label>1</label><nlm-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Morgan</surname><given-names>D. R.</given-names></name></person-group><article-title>An analysis of multiple correlation cancellation loops with a filter in the auxiliary path</article-title><source><italic>IEEE Transactions on Acoustics, Speech, and Signal Processing</italic></source><year>1980</year><volume>28</volume><issue>4</issue><fpage>454</fpage><lpage>467</lpage></nlm-citation></ref><ref id="B2" content-type="article"><label>2</label><nlm-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Burgess</surname><given-names>J. C.</given-names></name></person-group><article-title>Active adaptive sound control in a duct: a computer simulation</article-title><source><italic>Journal of the Acoustical Society of America</italic></source><year>1981</year><volume>70</volume><issue>3</issue><fpage>715</fpage><lpage>726</lpage><pub-id pub-id-type="doi">10.1121/1.386908</pub-id></nlm-citation></ref><ref id="B3" content-type="incollection"><label>3</label><nlm-citation publication-type="book"><person-group person-group-type="author"><name><surname>Kuo</surname><given-names>S. M.</given-names></name><name><surname>Morgan</surname><given-names>D. R.</given-names></name></person-group><person-group person-group-type="editor"><name><surname>Proakis</surname><given-names>J. G.</given-names></name></person-group><article-title>Adaptive transversal filters</article-title><source><italic>Active Noise Control Systems: Algorithms and DSP Implementations</italic></source><year>1996</year><publisher-loc>New York, NY, USA</publisher-loc><publisher-name>chapter 2, John Wiley &#x26; Sons</publisher-name><fpage>33</fpage><lpage>35</lpage></nlm-citation></ref><ref id="B4" content-type="article"><label>4</label><nlm-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Clark</surname><given-names>R. L.</given-names></name><name><surname>Gibbs</surname><given-names>G. P.</given-names></name></person-group><article-title>A novel approach to feedforward higher-harmonic control</article-title><source><italic>Journal of the Acoustical Society of America</italic></source><year>1994</year><volume>96</volume><issue>2</issue><fpage>926</fpage><lpage>936</lpage><pub-id pub-id-type="doi">10.1121/1.411389</pub-id></nlm-citation></ref><ref id="B5" content-type="article"><label>5</label><nlm-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Lee</surname><given-names>S. M.</given-names></name><name><surname>Lee</surname><given-names>H. J.</given-names></name><name><surname>Yoo</surname><given-names>C. H.</given-names></name><name><surname>Youn</surname><given-names>D. H.</given-names></name><name><surname>Cha</surname><given-names>I. W.</given-names></name></person-group><article-title>An active noise control algorithm for controlling multiple sinusoids</article-title><source><italic>Journal of the Acoustical Society of America</italic></source><year>1998</year><volume>104</volume><issue>1</issue><fpage>248</fpage><lpage>254</lpage><pub-id pub-id-type="doi">10.1121/1.423276</pub-id></nlm-citation></ref><ref id="B6" content-type="inproceedings"><label>6</label><nlm-citation publication-type="confproc"><person-group person-group-type="author"><name><surname>Kuo</surname><given-names>S. M.</given-names></name><name><surname>Kong</surname><given-names>X.</given-names></name><name><surname>Chen</surname><given-names>S.</given-names></name><name><surname>Hao</surname><given-names>W.</given-names></name></person-group><article-title>Analysis and design of narrowband active noise control systems</article-title><volume>6</volume><conf-name>Proceedings of the IEEE International Conference on Acoustics, Speech and Signal Processing
(ICASSP &#x27;98)</conf-name><conf-date>May 1998</conf-date><conf-loc>Seattle, Wash, USA</conf-loc><fpage>3557</fpage><lpage>3560</lpage><pub-id pub-id-type="doi">10.1109/ICASSP.1998.679642</pub-id></nlm-citation></ref><ref id="B7" content-type="inproceedings"><label>7</label><nlm-citation publication-type="confproc"><person-group person-group-type="author"><name><surname>Elliott</surname><given-names>S. J.</given-names></name><name><surname>Cook</surname><given-names>J. G.</given-names></name></person-group><article-title>A preconditioned LMS algorithm for rapid adaptation of feedforward controllers</article-title><volume>2</volume><conf-name>Proceedings of the IEEE International Conference on Acoustics, Speech and Signal Processing 
(ICASSP &#x27;00)</conf-name><conf-date>June 2000</conf-date><conf-loc>Istanbul, Turkey</conf-loc><fpage>845</fpage><lpage>848</lpage><pub-id pub-id-type="doi">10.1109/ICASSP.2000.859092</pub-id></nlm-citation></ref><ref id="B8" content-type="unpublished"><label>8</label><nlm-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Thomas</surname><given-names>J. K.</given-names></name><name><surname>Lovstedt</surname><given-names>S. P.</given-names></name><name><surname>Blotter</surname><given-names>J. D.</given-names></name><name><surname>Sommerfeldt</surname><given-names>S. D.</given-names></name></person-group><article-title>Eigenvalue equalization filtered-x algorithm for the multi-channel active noise control of 
stationary and  non-stationary signals</article-title><comment>submitted to <italic>Journal of the Acoustical Society of America</italic></comment></nlm-citation></ref><ref id="B9" content-type="article"><label>9</label><nlm-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Boucher</surname><given-names>C. C.</given-names></name><name><surname>Elliott</surname><given-names>S. J.</given-names></name><name><surname>Nelson</surname><given-names>P. A.</given-names></name></person-group><article-title>Effect of errors in the plant model on the performance of algorithms for adaptive feedforward control</article-title><source><italic>IEE Proceedings F</italic></source><year>1991</year><volume>138</volume><issue>4</issue><fpage>313</fpage><lpage>319</lpage></nlm-citation></ref><ref id="B10" content-type="article"><label>10</label><nlm-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Elliott</surname><given-names>S. J.</given-names></name><name><surname>Nelson</surname><given-names>P. A.</given-names></name></person-group><article-title>Active noise control</article-title><source><italic>IEEE Signal Processing Magazine</italic></source><year>1993</year><volume>10</volume><issue>4</issue><fpage>12</fpage><lpage>35</lpage><pub-id pub-id-type="doi">10.1109/79.248551</pub-id></nlm-citation></ref><ref id="B11" content-type="book"><label>11</label><nlm-citation publication-type="book"><person-group person-group-type="author"><name><surname>Widrow</surname><given-names>B.</given-names></name><name><surname>Stearns</surname><given-names>S. D.</given-names></name></person-group><source><italic>Adaptive Signal Processing</italic></source><year>1985</year><publisher-loc>Englewood Cliffs, NJ, USA</publisher-loc><publisher-name>Prentice-Hall</publisher-name></nlm-citation></ref><ref id="B12" content-type="book"><label>12</label><nlm-citation publication-type="book"><person-group person-group-type="author"><name><surname>Davis</surname><given-names>L.</given-names></name></person-group><source><italic>Handbook of Genetic Algorithms</italic></source><year>1991</year><publisher-loc>New York, NY, USA</publisher-loc><publisher-name>Van Nostrand Reinhold</publisher-name></nlm-citation></ref><ref id="B13" content-type="book"><label>13</label><nlm-citation publication-type="book"><person-group person-group-type="author"><name><surname>Goldberg</surname><given-names>D.</given-names></name></person-group><source><italic>Genetic Algorithms in Search, Optimization, and Machine Learning</italic></source><year>1989</year><publisher-loc>Reading, Mass, USA</publisher-loc><publisher-name>Addison-Wesley</publisher-name></nlm-citation></ref><ref id="B14" content-type="incollection"><label>14</label><nlm-citation publication-type="book"><person-group person-group-type="author"><name><surname>Kuo</surname><given-names>S. M.</given-names></name><name><surname>Morgan</surname><given-names>D. R.</given-names></name></person-group><person-group person-group-type="editor"><name><surname>Proakis</surname><given-names>J. G.</given-names></name></person-group><article-title>On-line secondary path modeling techniques</article-title><source><italic>Active Noise Control Systems: Algorithms and DSP Implementations</italic></source><year>1996</year><publisher-loc>New York, NY, USA</publisher-loc><publisher-name>chapter 7, John Wiley &#x26; Sons</publisher-name><fpage>213</fpage><lpage>240</lpage></nlm-citation></ref></ref-list></back></article>